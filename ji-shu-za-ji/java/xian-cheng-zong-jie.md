2015-11-18 线程总结
# 概念和原理
## 操作系统中线程和进程的概念
线程是指进程中的一个执行流程，一个进程中可以运行多个线程。线程总是属于某个进程，进程中的多个线程共享进程的内存。
## Java中的线程
每个线程都有一个调用栈，即使不在程序中创建任何新的线程，线程也在后台运行着。
一个Java应用总是从main()方法开始运行，main()方法运行在主线程内。
线程总体分两类：用户线程和守候线程。当所有用户线程执行完毕时，JVM自动关闭。但是守候线程却不独立于JVM，守候线程一般是由操作系统或者用户自己创建的。
# 创建和启动
## 定义和实例化线程
- 继承java.lang.Thread类，直接通过new来实例化。
- 实现java.lang.Runnable接口，用Thread的构造方法来实例化。
## 启动线程
在线程的Thread对象上调用start()方法，之后发生了一系列复杂的事情：
- 启动新的执行线程（具有新的调用栈）；
- 该线程从新状态转移到可运行状态；
- 当该线程获得机会执行时，其目标run()方法将运行。
> 线程的调度是JVM的一部分，在一个CPU的机器上上，实际上一次只能运行一个线程。一次只有一个线程栈执行。JVM线程调度程序决定实际运行哪个处于可运行状态的线程。
# 线程的状态
- 新状态
- 可运行状态
- 运行状态
- 等待/阻塞/睡眠状态
- 死亡态
## 线程被阻止运行
不考虑IO阻塞的情况下，有如下3中情况：
- 睡眠；
- 等待；
- 因为需要一个对象的锁定而被阻塞。
## 睡眠Thread.sleep(long millis)
当线程睡眠时，它入睡在某个地方，在苏醒之前不会返回到可运行状态。当睡眠时间到期，则返回到可运行状态。
Thread.sleep()使当前线程睡眠至少多少毫秒（尽管它可能在指定的时间之前被中断）。
## 让步Thread.yield()
调用Thread.yield()：不能保障太多事情，尽管通常它会让当前运行线程回到可运行性状态，使得有相同优先级的线程有机会执行。
yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。
> 线程总是存在优先级，优先级范围在1~10之间。JVM线程调度程序是基于优先级的抢先调度机制。在大多数情况下，当前运行的线程优先级将大于或等于线程池中任何线程的优先级。但这仅仅是大多数情况。
## join()
Thread的非静态方法join()让一个线程B“加入”到另外一个线程A的尾部。在A执行完毕之前，B不能工作。
然而，如果它加入的线程没有存活，则当前线程不需要停止。
## 其他
还有下面几种特殊情况可能使线程离开运行状态：
1、线程的run()方法完成。
2、在对象上调用wait()方法（不是在线程上调用）。
3、线程不能在对象上获得锁定，它正试图运行该对象的方法代码。
4、线程调度程序可以决定将当前运行状态移动到可运行状态，以便让另一个线程获得运行机会，而不需要任何理由。
# 线程的同步与锁
Java中每个对象都有一个内置锁。
当程序运行到非静态的synchronized同步方法上时，自动获得与正在执行代码类的当前实例（this实例）有关的锁。获得一个对象的锁也称为获取锁、锁定对象、在对象上锁定或在对象上同步。
一个对象只有一个锁。所以，如果一个线程获得该锁，就没有其他线程可以获得锁，直到第一个线程释放（或返回）锁。这也意味着任何其他线程都不能进入该对象上的synchronized方法或代码块，直到该锁被释放。
当一个类已经很好的同步以保护它的数据时，这个类就称为“线程安全的”。
> 何时需要同步?
 在多个线程同时访问互斥（可交换）数据时，应该同步以保护数据，确保两个线程不会同时修改更改它。
# 线程的交互
void notify()
  唤醒在此对象监视器上等待的单个线程。
 void notifyAll()
  唤醒在此对象监视器上等待的所有线程。
 void wait()
  导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。
# 守护线程
public final void setDaemon(boolean on)将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。
  该方法必须在启动线程前调用。
参考网址：http://lavasoft.blog.51cto.com/62575/222742